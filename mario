#pragma once
#include <SFML/Graphics.hpp>
#include <vector>
#include <string>
#include "collision.h"
#include "MapDraw.h"

using namespace std;

class Mario : public sf::Drawable,public sf::Transformable {
private:
	sf::Texture Texture;
	sf::Vector2f postion = sf::Vector2f({ 100,100 });
	sf::Vector2f old = sf::Vector2f({ 100,150 });
	float acceleration = 5.656854f, g = 1.f, maxspeed =16.f, speed = 10.343f, jumppower =-11.3137,maxy, velocityY=0;
	sf::IntRect stand,moverect[3],jumprect,die;
	sf::Clock mclock,jclock;
public:
	sf::Sprite Marios;
	bool ismoving = false, isonground = false, isjumping = false, isalive = true;
	Mario(std::filesystem::path& p) : Marios(Texture) {
		Texture.loadFromFile(p);
		Marios.setPosition({ 10,10 });
		Marios.scale({ 1,1 });
		stand =sf::IntRect({ 0,48 }, { 16,16 });
		moverect[0] = sf::IntRect({16,48},{16,15});
		moverect[1] = sf::IntRect({32,48},{16,16});
		moverect[2] = sf::IntRect({48,48},{16,16});
		jumprect = sf::IntRect({ 64,48 }, { 16,16 });
		die = sf::IntRect({ 80,48 }, { 16,16 });
	}

	void move() {
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left))L_move();
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right))R_move();
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Space)) jump();
	}

	void L_move() {
		Marios.setScale({ -1,1 });
		float dt = jclock.restart().asSeconds();
		if (speed < maxspeed) {
			speed += acceleration*dt;
		}
		else speed = maxspeed;
		ismoving = true;
		postion.x -= speed;
	}
	void R_move() {
		Marios.setScale({ 1,1 });
		float dt = jclock.restart().asSeconds();
		if (speed < maxspeed)speed += acceleration * dt;
		else speed = maxspeed;
		ismoving = true;
		postion.x += speed;
	}
	void jump() {
		if (isonground) {
			isjumping = true;
			isonground = false;
			velocityY = jumppower;
		}
	}
	void stop() {
		if (!ismoving) {
			if (speed > 0)
				speed -= acceleration;
			else if (speed < 0)
				speed += acceleration;
			if (speed == 0) {
				ismoving = false;
			}
		}
		Marios.setPosition(postion);
	}
	void animation() {
		if (isalive) {
			if (!isonground)Marios.setTextureRect(jumprect);
			else if (ismoving) {

				if (mclock.getElapsedTime().asMilliseconds() >= 150) {
					static int f = 0;
					Marios.setTextureRect(moverect[f]);
					f = (f + 1) % 3;
					mclock.restart();
				}
			}
			else if (!ismoving && !isjumping)Marios.setTextureRect(stand);
		}
		else Marios.setTextureRect(die);
	}

	void physics(sf::Vector2f& old, vector<int> map, sf::Vector2u block, sf::Vector2u size) {
		if (isalive) {
			if (isjumping||!isonground) {
				velocityY += g ;
				postion.y += velocityY;
			}
		}
		if (speed == 0)ismoving = false;
		if (!ismoving)stop();
		hcollison(old, map, block, size);
		Marios.setPosition(postion);
	}
	void viewupdate(sf::View& v1) {
		if (postion.x > 0 && postion.x < 800 && postion.y >0 && postion.y < 250)v1.setCenter(postion);
		else v1.setCenter(v1.getCenter());
	}
	void hcollison(sf::Vector2f& old,vector<int> map,sf::Vector2u block,sf::Vector2u size) {
		Collision check;
		char side = ' ';
		sf::FloatRect c1 = Marios.getGlobalBounds();
		for (unsigned int i = 0; i < size.x; i++) {
			for (unsigned int j = 0; j < size.y; j++) {
				sf::FloatRect c2 = sf::FloatRect({ i * block.x*1.f,j * block.y*1.f }, { block.x*1.f,block.y*1.f });
				const int tn = map[i + (j * size.x)];
				if (tn >= 0 && check.check(c1, c2, side)) {
					if (side == 'R') {
						speed = 0;
						postion.x -= 16;
						ismoving = false;
					}
					else if (side == 'L') {
						speed = 0;
						postion.x += 16;
						ismoving = false;
					}
					if (side == 'U') {
						velocityY = 0;
						postion.y += 1;
						isjumping = false;
					}
					else if (side == 'D') {
						velocityY = 0;
						postion.y -= 1;
						isonground = true;
						isjumping = false;
					}
				}
			}
		}
		
	}
	void update(sf::View& v1,vector<int> map,sf::Vector2u block,sf::Vector2u size) {
		old = postion;
		move();
		physics(old, map, block, size);
		animation();
		viewupdate(v1);
	}
private:
	virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override {
		target.draw(Marios, states);
	}
};
